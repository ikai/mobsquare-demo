import tornado.ioloop
import tornado.web
from tornado import httpclient 

import urllib
import re
import json
import os
import datetime

import config
import db
import items

# TODO: Change to use urllib.urlencode()
CALLBACK_URL = urllib.quote(config.REDIRECT_URL + "/callback")
LOGIN_URL = "https://www.facebook.com/dialog/oauth?client_id=%s&redirect_uri=%s&scope=email,user_checkins,publish_checkins,manage_friendlists" % (config.FACEBOOK_APPLICATION_ID, CALLBACK_URL)
ACCESS_TOKEN_URL_TPL = "https://graph.facebook.com/oauth/access_token?client_id=" + config.FACEBOOK_APPLICATION_ID \
  + "&redirect_uri=" + CALLBACK_URL \
  + "&client_secret=" + config.FACEBOOK_APPLICATION_SECRET \
  + "&code="
  
API = {
    "base"      : "https://graph.facebook.com/%s",
    "profile"   : "https://graph.facebook.com/me?access_token=%s",
    "places"    : "https://graph.facebook.com/search?type=place&center=%(lat)s,%(lon)s&distance=%(distance)d&access_token=%(access_token)s"
}

def require_facebook_login(f):
    """ 
        This decorator forces a handler to require a Facebook login by checking 
        for a user_id and passing it as a keyword argument.
    """
    def new_f(self, *args):
        user_id = self.get_secure_cookie("user_id")
        if not user_id:
            # Probably want to do something here
            self.redirect("/login")
            self.finish()
        else:
            f(self, *args)
    return new_f    

class MainHandler(tornado.web.RequestHandler):
    """ Renders the main page """
    @require_facebook_login
    def get(self):
        user_id = self.get_secure_cookie("user_id")
        user = db.get_user(user_id)
        self.render("templates/main.html", user_id=user_id)

class LogoutHandler(tornado.web.RequestHandler):
    """ Handles logout requests """
    def get(self):
        self.clear_cookie("user_id")
        self.render("templates/logout.html")
        
class LoginHandler(tornado.web.RequestHandler):
    """ Redirects the user to the Facebook login URL to get authorization for our app """
    def get(self):
        self.redirect(LOGIN_URL)
        
ACCESS_TOKEN_REGEX = re.compile("access_token=(.*)&expires=(.*)")
class OnLoginHandler(tornado.web.RequestHandler):
    """
        This handler takes care of logins after the user has authorized our 
        Application on Facebook. It's a 3 step process. The callback flow
        goes something like this:
        
        1. Parse out the code from the callback. This is passed as an
           URL parameter "code"
           
        2. Make an asynchronous request to Facebook to authorize this
           code. We do this by signing passing our secret key along.
           From this, we receive an auth token for making API calls.
           
        3. Make another asynchronous request to Facebook to fetch
           profile details. Save this to MongoDB. Use the autogenerated
           BSON ObjectId as our session key.
           
        TODO: Expire old sessions. Auth tokens have an expiry, this should
        be persisted somewhere.
    """
    
    @tornado.web.asynchronous
    def get(self):
        # Store this somewhere
        code = self.get_argument("code")
        access_token_url = ACCESS_TOKEN_URL_TPL + code
        client = httpclient.AsyncHTTPClient()
        client.fetch(access_token_url, self.on_fetched_token)
        
    def on_fetched_token(self, response):
        """ Callback inokved when the auth_token is fetched """
        if response.error:
            print "Error:", response.error
        else:
            body = response.body
            matches = ACCESS_TOKEN_REGEX.search(body)
            if matches:
                access_token = matches.group(1)
                client = httpclient.AsyncHTTPClient()
                # lambda is effectively a function factory for us
                client.fetch(API["profile"] % access_token, lambda response: self.on_profile_fetch(response, access_token))      
                
    def on_profile_fetch(self, response, access_token):
        """ Callback invoked when we have fetched the user's profile """
        if response.error:
            print "Error:", response.error
        else:
            profile = json.loads(response.body)
            profile["access_token"] = access_token
            profile_id = db.save_profile(profile)
            self.set_secure_cookie("user_id", str(profile_id))
            self.redirect("/") # implictly calls self.finish()

  
class NearbyLocationsHandler(tornado.web.RequestHandler):
    """ 
        Serves locations nearby. Returns JSON. This is typically invoked
        via an XHR get because the browser needs to use the JavaScript
        geolocation API to determine the current user's lat/long. Makes
        use of Facebook's Places API, then maps these to game metadata
        associated with each of the places returned.
    """
    
    @tornado.web.asynchronous
    @require_facebook_login
    def get(self):
        user_id = self.get_secure_cookie("user_id")
        lat = self.get_argument("lat")
        lon = self.get_argument("lon")
        user = db.get_user(user_id)
        
        url = API["places"] % { "lat" : lat, 
                                "lon" : lon,
                                "distance" : 1000,
                                "access_token" : user["access_token"] }
        
        client = httpclient.AsyncHTTPClient()
        client.fetch(url, self.on_fetch_places)
            
    def on_fetch_places(self, response):
        """ Callback invoked after places fetched """
        places = json.loads(response.body)
        
        location_ids = [location["id"] for location in places["data"]]
        data = db.get_locations(location_ids)

        # Add additional metadata we've stored locally
        for location in places["data"]:
            if location["id"] in data.keys():
                # micro JS template doesn't like conditionals
                location["data"] = data[location["id"]]
                # if loc_data["owner"] is not None:
                #     location["owner_name"] = loc_data["owner"]["name"]
                    
                # json.dumps doesn't serialize datetime.datetime instances
                # see http://twitter.com/#!/ikai/status/78364766720098304
                if location["data"]["last_extort_time"] is not None:
                    # We can fix this nonsense later
                    location["data"]["last_extort_time"] = str(location["data"]["last_extort_time"])
            
        self.write(json.dumps(places))
        self.finish()
        
class LocationHandler(tornado.web.RequestHandler):
    """ 
        Returns data about a particular location. This Handler is invoked at
        /location/LOCATION_ID, where LOCATION_ID maps to an ID of the location
        as specified in Facebook's Graph API. Merge with local data.
        
        POST handler updates this location.
        
        Renders an HTML page.
    """
    
    @tornado.web.asynchronous
    @require_facebook_login
    def get(self, location_id):
        """ Fetches location data """
        url = API["base"] % location_id
        client = httpclient.AsyncHTTPClient()
        client.fetch(url, self.on_fetch_location)
    
    @require_facebook_login
    def post(self, location_id):
        """
            This handler is a bit more complex - handles the actions that can 
            be taken at this location. For instance:
            
            - extort
            - take control
            - leave guards
            - battle
        """
        user_id = self.get_secure_cookie("user_id")
        user = db.get_user(user_id)
                    
        location = db.get_or_create_location_by_id(location_id)
        action = self.get_argument("action")

        if action == "take-control":
            # TODO: Do an additional check to make sure this isn't owned
            # by someone else and there are no guards here.
            location["owner"] = { "name" : user["name"], "user_id" : user["id"] }
            db.save_location(location)
        elif action == "extort" and location["owner"]["user_id"] == user["id"]:
            inventory = db.get_inventory_for_user(user)
            extortion_value = 5 * location["checkins"]
            inventory["money"] += extortion_value
            db.save_inventory(inventory)
            
            location["last_extort_time"] = datetime.datetime.now()
            db.save_location(location)
            
        self.redirect("/location/%s" % location_id)
            
    def on_fetch_location(self, response):
        """ 
            Callback invoked when we get location data. Lazily check to see if
            we already have an entry in MongoDB about this location or not. If
            not, create one.
        """
        user_id = self.get_secure_cookie("user_id")
        user = db.get_user(user_id)
        
        location = json.loads(response.body)
        location_data = db.get_or_create_location_by_id(location["id"])
        
        # Lazy get this
        location_data["checkins"] = location["checkins"]
        db.save_location(location_data)
        
        inventory = db.get_inventory_for_user(user)
        
        # power is a function of checkins * something
        self.render("templates/location.html",
            datetime=datetime,
            location=location, 
            data=location_data, 
            current_user=user,
            inventory=inventory)    

        
class StoreHandler(tornado.web.RequestHandler):
    """
        Handler for store and inventory actions.
    """
    @require_facebook_login
    def get(self):
        """ 
            Fetches the purchasable items from the datastore and renders
            them to the user via HTML.
        """
        user_id = self.get_secure_cookie("user_id")
        user = db.get_user(user_id)
        inventory = db.get_inventory_for_user(user)
                
        self.render("templates/store.html",
            inventory=inventory,
            mobsters=items.mobsters,
            weapons=items.weapons,
            armor_list=items.armor_list)
        
    @require_facebook_login
    def post(self):
        """
            Allows a user to make purchases. In the case of armor or weapons, we
            simply increment the number of items a user has.
            
            In the case of mobsters, we append to the current list of mobsters in the
            player's inventory because each mobster has its own state.
        """
        user_id = self.get_secure_cookie("user_id")
        user = db.get_user(user_id)
        inventory = self.get_inventory_for_user(user)
        
        action = self.get_argument("action")
        item_id = self.get_argument("id")
        
        # Probably could have collapsed armor and weapons into a single
        # type and used a field to designate type.
        if action == "buy-weapon":
            # User already has item, increment quantity
            weapon = items.weapons[item_id]
            if item_id in inventory["weapons"].keys():
                inventory["weapons"][item_id]["quantity"] += 1
            else:
                inventory["weapons"][item_id] = {
                    "name" : weapon["name"],
                    "quantity" : 1
                }
        elif action == "buy-armor":
            armor = items.armor_list[item_id]
            if item_id in inventory["armor"].keys():
                inventory["armor"][item_id]["quantity"] += 1
            else:
                inventory["armor"][item_id] = {
                    "name" : armor["name"],
                    "quantity" : 1
                }
        elif action == "recruit-mobster":
            # We are recruiting someone to our gang. We persist this data
            # differently because we have to store the state of each mobster.
            mobster_prototype = items.mobsters[item_id]
            
            # We create a new instance of a mobster to track state
            mobster_instance = {
                "name" : mobster_prototype["name"],
                "image_url" : mobster_prototype["image_url"],
                "level" : mobster_prototype["level"],
                "hp" : mobster_prototype["base_hitpoints"],
                # We may want to modify this later with bonuses
                "damage" : mobster_prototype["base_damage"]
            }
            inventory["mobsters"].append(mobster_instance)
            
        db.save_inventory(inventory)
        self.redirect("/store")
        

application = tornado.web.Application([
    (r"/", MainHandler),
    (r"/login", LoginHandler),
    (r"/logout", LogoutHandler),
    (r"/callback", OnLoginHandler),
    (r"/nearby", NearbyLocationsHandler),
    (r"/location/([0-9]+)", LocationHandler),
    (r"/store", StoreHandler)
], cookie_secret=config.COOKIE_SECRET,
   static_path=os.path.join(os.path.dirname(__file__), "static"),
   debug=True)

if __name__ == "__main__":
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
